{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"TreeAlgorithms This is the summary for TreeAlgorithms. To see the reference, go here . Abstract <jv/tree-algorithms.hpp> provides several utilities to iterate over a tree represented as a node sequence. This allows to represent a tree as a sequence of nodes (for instance std::vector<Node> ), instead of pointers to relatives. This is beneficial for cache-locality. Explanatory example For instance, the following expression sqrt( pow(3,2) + pow(4,2) ) corresponds to this tree: sqrt |-> add |-> pow | |-> 3 | |-> 2 |-> pow |-> 4 |-> 2 This can be translated in the following sequence: using MathTree = vector<OperationOrValue>; MathTree sequence { Operation::Sqrt, Operation::Add, Value{3}, Value{2}, Operation::Pow, Value{4}, Value{2} }; ( OperationOrValue could be a std::unique_ptr to a polymorphic base class, or to a std::variant<Operation, Value> ...) To exploit this using tree algorithms, we need to provide a NodeTraits . This is because, in order to retrieve the tree structure, we need to know the number of children of every node. In this example, operations have two children, and values have zero children. struct MyNodeTraits : jv::NodeTraits<MathTree::iterator, MyNodeTraits> { static std::size_t getChildrenCount(iterator it) noexcept { if (*it is Operation) return 2; else return 0; } }; Note that jv::NodeTraits is a template instantiated with MathTree::iterator and MyNodeTraits . The first template argument of jv::NodeTraits is the iterator type of the sequence. It must meet the requirements of InputIterator . The second template argument of jv::NodeTraits is the node traits we are creating. This is called CRTP ( Curiously Recurring Template Pattern ). It can be considered the equivalent of virtual polymorphism for templates. Once this is done, we can call algorithms on the tree. double evaluate_tree(MathTree const& tree) { // this calls the provided function for each child, then it is called for their // parent using the values generated by its children. auto [value, tree_end] = MyNodeTraits::evaluationTraversal<double>( tree.begin(), [](MathTree::iterator node, double* begin, double* end) { // begin and end is a range of the children's evaluation values. if (*node is Operation) { assert(end - begin == 2); // number of children is 2 return (*node as Operation)->apply(begin[0], begin[1]); } else { assert(end - begin == 0); // number of children is 0 return (*node as Value)->get_value(); } }); assert(tree_end == tree.end()); return value; } The complete example of this math evaluation can be found in the source file examples/polish-notation.cpp .","title":"TreeAlgorithms"},{"location":"#treealgorithms","text":"This is the summary for TreeAlgorithms. To see the reference, go here .","title":"TreeAlgorithms"},{"location":"#abstract","text":"<jv/tree-algorithms.hpp> provides several utilities to iterate over a tree represented as a node sequence. This allows to represent a tree as a sequence of nodes (for instance std::vector<Node> ), instead of pointers to relatives. This is beneficial for cache-locality.","title":"Abstract"},{"location":"#explanatory-example","text":"For instance, the following expression sqrt( pow(3,2) + pow(4,2) ) corresponds to this tree: sqrt |-> add |-> pow | |-> 3 | |-> 2 |-> pow |-> 4 |-> 2 This can be translated in the following sequence: using MathTree = vector<OperationOrValue>; MathTree sequence { Operation::Sqrt, Operation::Add, Value{3}, Value{2}, Operation::Pow, Value{4}, Value{2} }; ( OperationOrValue could be a std::unique_ptr to a polymorphic base class, or to a std::variant<Operation, Value> ...) To exploit this using tree algorithms, we need to provide a NodeTraits . This is because, in order to retrieve the tree structure, we need to know the number of children of every node. In this example, operations have two children, and values have zero children. struct MyNodeTraits : jv::NodeTraits<MathTree::iterator, MyNodeTraits> { static std::size_t getChildrenCount(iterator it) noexcept { if (*it is Operation) return 2; else return 0; } }; Note that jv::NodeTraits is a template instantiated with MathTree::iterator and MyNodeTraits . The first template argument of jv::NodeTraits is the iterator type of the sequence. It must meet the requirements of InputIterator . The second template argument of jv::NodeTraits is the node traits we are creating. This is called CRTP ( Curiously Recurring Template Pattern ). It can be considered the equivalent of virtual polymorphism for templates. Once this is done, we can call algorithms on the tree. double evaluate_tree(MathTree const& tree) { // this calls the provided function for each child, then it is called for their // parent using the values generated by its children. auto [value, tree_end] = MyNodeTraits::evaluationTraversal<double>( tree.begin(), [](MathTree::iterator node, double* begin, double* end) { // begin and end is a range of the children's evaluation values. if (*node is Operation) { assert(end - begin == 2); // number of children is 2 return (*node as Operation)->apply(begin[0], begin[1]); } else { assert(end - begin == 0); // number of children is 0 return (*node as Value)->get_value(); } }); assert(tree_end == tree.end()); return value; } The complete example of this math evaluation can be found in the source file examples/polish-notation.cpp .","title":"Explanatory example"},{"location":"reference/","text":"Reference of This is the reference page for TreeAlgorithms. To see the summary and examples, go here . NodeTraits creation You must provide the access to the number of children of each node. This is done by creating you own NodeTraits deriving from jv::NodeTraits . The method name and signature must match exactly the one provided below. struct MyNodeTraits : jv::NodeTraits<MyIterator, MyNodeTraits> { static std::size_t getChildrenCount(iterator it) noexcept { ... the code ... } }; jv::NodeTraits has two template parameters: InputIterator : the appropriate iterator to the sequence, which must satisfy the InputIterator requirement. Crtp : the NodeTraits you are creating, this is needed for dispatching function calls After this, the NodeTraits you have created has the following methods: recursiveTraversal(node, func) Interface template <typename Func> static iterator recursiveTraversal(iterator node, Func&& func); Parameters node ( iterator ): The node for which we will traverse its children func ( Func ): A function that matches the signature (iterator, Func&)->iterator returns ( iterator ): Pointer to the next sibling of node Description This function is intended to be called inside the func you provide, this is how the recursion is made. Any function based on recursiveTraversal has the following structure: void myFunction(iterator root) { ... initialisation ... recursiveTraversal(root, [] (iterator node, auto& self) { ... before children traversal ... iterator next_node = recursiveTraversal(node, self); ... after children traversal ... return next_node; }); } Notes This is a low-level function, but it provides the most customisation possible. ancestorsTraversal and evaluationTraversal are implemented using recursiveTraversal . You can check the implementation of these functions to have examples on how to use recursiveTraversal . ancestorsTraversal(node, func, alloc = {}) Interface template <typename Allocator = std::allocator<iterator>, typename Func> static iterator ancestorsTraversal(iterator root, Func&& func, Allocator alloc = {}) Parameters root ( iterator ): The node which is the root of the tree func ( Func ): A function that can be called with (iterator* begin, iterator* end) alloc ( Allocator ): An allocator used internally for a vector<iterator, Allocator> returns ( iterator ): Pointer to the next sibling of node Description This function calls func for every node, and it provides a range to all the ancestors of the current node. For instance, with the following tree: A |-> B | |-> C | |-> D |-> E |-> F |-> G |-> H func will be called 8 times, with the following ranges: Call #1: { A } Call #2: { A, B } Call #3: { A, B, C } Call #4: { A, B, D } Call #5: { A, E } Call #6: { A, F } Call #7: { A, F, G } Call #8: { A, F, H } evaluationTraversal (node, func, alloc = {}) Interface template <typename Value, typename Allocator = std::allocator<Value>, typename Func> static std::pair<Value, iterator> evaluationTraversal(iterator root, Func&& func, Allocator alloc = {}) Parameters root ( iterator ): The node which is the root of the tree func ( Func ): A function that can be called with (iterator node, Value* begin, Value* end) alloc ( Allocator ): An allocator used internally for a vector<Value, Allocator> returns ( pair<Value, iterator> ): Pointer to the next sibling of node Description This function calls func for every node, starting by children. func produces intermediary values of type Value that are passed to the parent. For instance, with the following tree: A |-> B | |-> C | |-> D |-> E |-> F |-> G |-> H func will be called 8 times, with the following ranges: // indentation is only for visualization purposes Call #1: value_C = func(C, {}) Call #2: value_D = func(D, {}) Call #3: value_B = func(B, { value_C, value_D }) Call #4: value_E = func(E, {}) Call #5: value_G = func(G, {}) Call #6: value_H = func(H, {}) Call #7: value_F = func(F, { value_G, value_H }) Call #8: value_A = func(A, { value_B, value_E, value_F })","title":"Reference of <jv/tree-algorithms.hpp>"},{"location":"reference/#reference-of","text":"This is the reference page for TreeAlgorithms. To see the summary and examples, go here .","title":"Reference of "},{"location":"reference/#nodetraits-creation","text":"You must provide the access to the number of children of each node. This is done by creating you own NodeTraits deriving from jv::NodeTraits . The method name and signature must match exactly the one provided below. struct MyNodeTraits : jv::NodeTraits<MyIterator, MyNodeTraits> { static std::size_t getChildrenCount(iterator it) noexcept { ... the code ... } }; jv::NodeTraits has two template parameters: InputIterator : the appropriate iterator to the sequence, which must satisfy the InputIterator requirement. Crtp : the NodeTraits you are creating, this is needed for dispatching function calls After this, the NodeTraits you have created has the following methods:","title":"NodeTraits creation"},{"location":"reference/#recursivetraversalnode-func","text":"","title":"recursiveTraversal(node, func)"},{"location":"reference/#interface","text":"template <typename Func> static iterator recursiveTraversal(iterator node, Func&& func);","title":"Interface"},{"location":"reference/#parameters","text":"node ( iterator ): The node for which we will traverse its children func ( Func ): A function that matches the signature (iterator, Func&)->iterator returns ( iterator ): Pointer to the next sibling of node","title":"Parameters"},{"location":"reference/#description","text":"This function is intended to be called inside the func you provide, this is how the recursion is made. Any function based on recursiveTraversal has the following structure: void myFunction(iterator root) { ... initialisation ... recursiveTraversal(root, [] (iterator node, auto& self) { ... before children traversal ... iterator next_node = recursiveTraversal(node, self); ... after children traversal ... return next_node; }); }","title":"Description"},{"location":"reference/#notes","text":"This is a low-level function, but it provides the most customisation possible. ancestorsTraversal and evaluationTraversal are implemented using recursiveTraversal . You can check the implementation of these functions to have examples on how to use recursiveTraversal .","title":"Notes"},{"location":"reference/#ancestorstraversalnode-func-alloc","text":"","title":"ancestorsTraversal(node, func, alloc = {})"},{"location":"reference/#interface_1","text":"template <typename Allocator = std::allocator<iterator>, typename Func> static iterator ancestorsTraversal(iterator root, Func&& func, Allocator alloc = {})","title":"Interface"},{"location":"reference/#parameters_1","text":"root ( iterator ): The node which is the root of the tree func ( Func ): A function that can be called with (iterator* begin, iterator* end) alloc ( Allocator ): An allocator used internally for a vector<iterator, Allocator> returns ( iterator ): Pointer to the next sibling of node","title":"Parameters"},{"location":"reference/#description_1","text":"This function calls func for every node, and it provides a range to all the ancestors of the current node. For instance, with the following tree: A |-> B | |-> C | |-> D |-> E |-> F |-> G |-> H func will be called 8 times, with the following ranges: Call #1: { A } Call #2: { A, B } Call #3: { A, B, C } Call #4: { A, B, D } Call #5: { A, E } Call #6: { A, F } Call #7: { A, F, G } Call #8: { A, F, H }","title":"Description"},{"location":"reference/#evaluationtraversalnode-func-alloc","text":"","title":"evaluationTraversal(node, func, alloc = {})"},{"location":"reference/#interface_2","text":"template <typename Value, typename Allocator = std::allocator<Value>, typename Func> static std::pair<Value, iterator> evaluationTraversal(iterator root, Func&& func, Allocator alloc = {})","title":"Interface"},{"location":"reference/#parameters_2","text":"root ( iterator ): The node which is the root of the tree func ( Func ): A function that can be called with (iterator node, Value* begin, Value* end) alloc ( Allocator ): An allocator used internally for a vector<Value, Allocator> returns ( pair<Value, iterator> ): Pointer to the next sibling of node","title":"Parameters"},{"location":"reference/#description_2","text":"This function calls func for every node, starting by children. func produces intermediary values of type Value that are passed to the parent. For instance, with the following tree: A |-> B | |-> C | |-> D |-> E |-> F |-> G |-> H func will be called 8 times, with the following ranges: // indentation is only for visualization purposes Call #1: value_C = func(C, {}) Call #2: value_D = func(D, {}) Call #3: value_B = func(B, { value_C, value_D }) Call #4: value_E = func(E, {}) Call #5: value_G = func(G, {}) Call #6: value_H = func(H, {}) Call #7: value_F = func(F, { value_G, value_H }) Call #8: value_A = func(A, { value_B, value_E, value_F })","title":"Description"}]}